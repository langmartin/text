#+TITLE: What Goes Around Comes Around

* Epochs

- Hierarchical (IMS): late 1960's and 1970's
- Network (CODASYL): 1970's
- Relational: 1970's and early 1980's Entity-Relationship: 1970's
- Extended Relational: 1980's
- Semantic: late 1970's and 1980's
- Object-oriented: late 1980's and early 1990's
- Object-relational: late 1980's and early 1990's

* Meta Lessons
:PROPERTIES:
:data-background: img/golden-arches.jpg
:data-state: blur
:END:

- Me: we end making these design tradeoffs in applications
- The market decides, not always wisely

* Terms

- Physical data independence: the ability to change unindexed data
  storage (like order of records) and run programs written for the old
  data storage layer
- Logical independence: add fields to db records, exlude them for a view

* Hierarchical
:PROPERTIES:
:data-background: img/big-key.jpg
:data-state: blur
:END:

** IMS
- Physical and logical data independence are highly desirable
- Tree structured data models are very restrictive
- It is a challenge to provide sophisticated logical reorganizations
  of tree structured data
- A record-at-a-time user interface forces the programmer to do
  manual query optimization, and this is often hard.

* Network
:PROPERTIES:
:data-background: img/bunch-keys.jpg
:data-state: blur
:END:

** CODASYL

- Networks are more flexible than hierarchies but more complex
- Less physically and logically independent
- Loading and recovering networks is harder than hierarchies
  (broken pointers)

* The Great Debate

- Relational, set-at-a-time high level languages
- CODASYL is too complex to be good
- Record-at-a-time is too hard to optimize

vs.

- COBOL programmers can't understand new things
- Anyway, set languages can be built on CODASYL

* Relational
:PROPERTIES:
:data-background: img/rustic-table.jpg
:data-state: blur
:END:

- Set-a-time languages are good, regardless of the data model, since
  they offer much improved physical data independence
- Logical data independence is easier with a simple data model than
  with a complex one
- Query optimizers can beat all but the best record-at-a-time DBMS
  application programmers
- The market: VAX vs mainframe

* Entity-Relationship

- Functional dependencies are too difficult for mere mortals to
  understand. Another reason for KISS

* R++

- Unless there is a big performance or functionality advantage, new constructs will go nowhere.

* Semantic

- Packages will not sell to users unless they are in "major pain"

* Object Oriented

- Persistent languages will go nowhere without the support of the programming language community.

* Object Relational

- The major benefits of OR is two-fold. putting code in the data base (and thereby bluring the distinction between code and data) and user-defined access methods.
- Widespread adoption of new technology requires either standards and/or an elephant pushing hard.

* XML Predictions
** Lessons

17. Schema-last is a probably a niche market
18. XQuery is pretty much OR SQL with a different syntax
19. XML will not solve the semantic heterogeneity either inside or outside the enterprise.
