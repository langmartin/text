#+TITLE: What Goes Around Comes Around

* Epochs

- Hierarchical (IMS): late 1960's and 1970's
- Network (CODASYL): 1970's
- Relational: 1970's and early 1980's Entity-Relationship: 1970's
- Extended Relational: 1980's
- Semantic: late 1970's and 1980's
- Object-oriented: late 1980's and early 1990's
- Object-relational: late 1980's and early 1990's

* Meta Lessons
:PROPERTIES:
:data-background: img/golden-arches.jpg
:data-state: blur
:END:

- Me: we end making these design tradeoffs in applications
- The market decides, not always wisely

* Terms

- Physical data independence: the ability to change unindexed data
  storage (like order of records) and run programs written for the old
  data storage layer

* Hierarchical
:PROPERTIES:
:data-background: img/big-key.jpg
:data-state: blur
:END:

- Physical and logical data independence are highly desirable (but impossible)
- Tree structured data models are very restrictive
- It is a challenge to provide sophisticated logical reorganizations
  of tree structured data
- A record-at-a-time user interface forces the programmer to do
  manual query optimization, and this is often hard.

* Network
:PROPERTIES:
:data-background: img/bunch-keys.jpg
:data-state: blur
:END:

- Networks are more flexible than hierarchies but more complex
- Loading and recovering networks is more complex than hierarchies
  (broken pointers)

* Relational

- Set-a-time languages are good, regardless of the data model, since
  they offer much improved physical data independence.
- Logical data independence is easier with a simple data model than
  with a complex one.
- Technical debates are usually settled by the elephants of the
  marketplace, and often for reasons that have little to do with the
  technology.
- Query optimizers can beat all but the best record-at-a-time DBMS
  application programmers.

* Entity-Relationship

- Functional dependencies are too difficult for mere mortals to
  understand. Another reason for KISS

* R++

- Unless there is a big performance or functionality advantage, new constructs will go nowhere.

* Semantic

- Packages will not sell to users unless they are in "major pain"

* Object Oriented

- Persistent languages will go nowhere without the support of the programming language community.

* Object Relational

- The major benefits of OR is two-fold. putting code in the data base (and thereby bluring the distinction between code and data) and user-defined access methods.
- Widespread adoption of new technology requires either standards and/or an elephant pushing hard.

* XML Predictions
** Lessons

17. Schema-last is a probably a niche market
18. XQuery is pretty much OR SQL with a different syntax
19. XML will not solve the semantic heterogeneity either inside or outside the enterprise.
